## Гедымин
Как загрузка данных для отображения на экране в гриде работает в Гедымине:

1. Каждый экземпляр Гедымина -- это одно постоянное подключение (коннект) к базе данных.
2. Каждый экземпляр Гедымина имеет одну, постоянно открытую транзакцию в режиме read-only, которая используется для чтения данных.
3. Экранные компоненты типа грида подключены к набору данных TDataSet.
4. При открытии TDataSet выполняется SQL запрос к базе данных. Как правило запрос выполняется на общей транзакции для чтения, но иногда логика обработки данных требует выполнения запроса на своей, заданной, транзакции. Например, когда есть промежуточные, незакомиченные изменения, которые должны быть отображены на экране.
5. Изначально с сервера получается небольшое количество записей, необходимое для заполнения грида на экране. Данные располагаются в буфере TDataSet в оперативной памяти. Запрос к базе данных остается открытым.
6. Записи подгружаются по мере необходимости (скролинга в гриде).
7. При обращении к функциям сортировки и фильтрации в гриде проверяется загружены ли _все_ записи с сервера. Если нет, то записи загружаются и только потом происходит их сортировка или фильтрация в буфере на клиенте.
8. Пока все записи не попадут на клиента, агрегатные функции не вычисляются.
9. Загрузка большого набора данных на клиента может потребовать большого объема оперативной памяти. Длительная загрузка может быть прервана пользователем нажатием клавиши ESC.
10. Обновление набора данных по F5 вызывает закрытие запроса и открытие нового. Буфер записей в оперативной памяти уничтожается и заполняется по новой.


## GDMN
Как сейчас устроен GDMN:
1. При создании/загрузке приложения (объект через который организуется вся работа с бд) идет считываение структуры бд, создание ер модели и организация общего пула соединений к бд.
2. Каждая браузерная вкладка создает свою сессию внтури приложения со своей очередью задач. Один пользователь может открыть неограниченное число вкладок, соответственно и сессий.
3. После закрытия вкладки или при разрыве соединения сессия на определенное время переходит в режим ожидания восстановления. Если за это время сессию не восстановили, она полностью закрывается.
4. Каждая сессия имеет доступ к общему пулу соединений и по необходимости резервирует (соединение временно никто больше не может использовать) соединение для выполнения одной задачи, после чего сразу возвращает соединение обратно. Одна сессия может резервировать ограниченное число соединений, чтобы не истощить весь запас пула.

Есть два способа сделать поэтапную подгрузку данных:
1. Использовать FIRST/SKIP  
Могут быть проблемы с производительнотью. Без явного управления транзакциями с клиента, будут проблемы с синхронизацией при одновременной подгрузке и редактировании каких-то записей.

2. Использовать кэшированный на сервере ResultSet и обращатся за данными к нему  
Для этого нужно хранить ResultSet в сессии и резерировать соединение на время жизни ResultSet-а. При этом одновременное открытие нескольких ResultSet-ов быстро истощит запас выделенных под сессию соединений и последующие задачи будут ждать.
Однако можно реализовать механизм повторного использования этих соединения внутри текущей сессии. Для этого организовать внутри сессии дополнительный "абстрактный" пул соединений, который будет освобождать соединение для текущей сессии после создания ResultSet-а. Новая задача сначала будет проверять свободные соединения внутри сессии и только потом смотреть в сторону общего пула.
