Разделим задачу на три части:

1. Отображение заданных атрибутов из связанной сущности EntityAttribute в выборке.
2. Извлечение данных Entity по заданному ИД из EntityAttribute, допускающему ссылку на несколько типов Entity.
3. Формирование условий выборки записей Entity по атрибутам из связанной сущности EntityAttribute.

# 1a (EntityAttribute ссылается на одну сущность)

Предположим, перед нами стоит задача реализовать следующий пользовательский интерфейс:

1. Отобразить на экране список накладных на реализацию нашей продукции. 
2. У сущности **Накладная** EntityAttribute покупателя содержит ссылку только на одну сущность **Компания**.
3. В списке документов на экране, среди прочих атрибутов документа, мы хотим видеть **Наименование покупателя** и **Телефон покупателя**.
4. Рядом со списком необходимо отобразить панель, где для покупателя из текущей позиции в списке документов, показывать историю его покупок и платежей.

Для решения данной задачи, система должна: 
1. Определить из адаптеров атрибутов сущности **Компания** в каких таблицах находятся запрашиваемые поля. 
2. При формировании SQL запроса присоединить по `JOIN` или `LEFT JOIN` (в зависимости от того, обязательным или нет является атрибут **Компания** у сущности **Накладная**) определенную в п.1. таблицу(ы).
3. В части `SELECT` запроса добавить в список указанные поля.

Для нашей структуры БД части SQL запроса будут выглядеть следующим образом:
```sql
SELECT 
  ...
  z.customerkey,
  c.name,
  c.phone
  ...
FROM
  <таблица накладной> z
  JOIN gd_contact c ON z.customerkey = c.id
  ...
```
Если же будет задано показать **Наименование** и **УНП**, которые лежат в разных таблицах сущности **Компания**, то запрос примет следующий вид:
```sql
SELECT 
  ...
  z.customerkey,
  c.name,
  t.taxid
  ...
FROM
  <таблица накладной> z
  JOIN gd_contact c ON z.customerkey = c.id
  LEFT JOIN gd_companycode t ON z.customerkey = t.contactkey
  ...
```
Обратите внимание, что таблица `GD_COMPANYCODE` подключается через `LEFT JOIN` так как в адаптере сущности **Компания** данная таблица указана как `weak relation`:
```json
"adapter": {
  "relation": [
    {
      "relationName": "GD_CONTACT",
      "pk": [
        "ID"
      ],
      "selector": {
        "field": "CONTACTTYPE",
        "value": 3
      }
    },
    {
      "relationName": "GD_COMPANY",
      "pk": [
        "CONTACTKEY"
      ]
    },
    {
      "relationName": "GD_COMPANYCODE",
      "pk": [
        "CONTACTKEY"
      ],
      "weak": true
    }
  ]
}
```
В запросе так же извлекается ИД компании. При перемещении по таблице мы будем использовать этот ИД для того, чтобы формировать запросы на определение истории покупок и платежей клиента.

# 1b (EntityAttribute ссылается на несколько сущностей)

Рассмотрим пример аналогичный предыдущему, но теперь EntityAttribute сущности **Накладная** пусть ссылается на две сущности **Компания** и **Человек**.

Поставлена задача извлечь в запросе следующие данные: 
* Наименование компании, контактный телефон и УНП
* ФИО человека, контактный телефони и номер паспорта

В структуре нашей реляционной базы данных данная информация расположена в следующих таблицах:

```
               +-------------------+
               | GD_CONTACT        |
               | ...               |
         +-----| name              |-----+
         |     | phone             |     |
         |     | ...               |     |
         |     +-------------------+     |
         |                               |
+-------------------+        +-------------------+
| GD_PEOPLE         |        | GD_COMPANYCODE    |
| ...               |        | ...               |
| passport          |        | taxid             |
| ...               |        | ...               |
+-------------------+        +-------------------+
```
Следует понимать, что когда в ER Model мы указываем для EntityAttribute массив из нескольких Entity, в физической структуре БД это будет _одно поле_ с _одним внешним ключем (FOREIGN KEY)_, указывающим на _общую_ для всех указанных Entity таблицу.

Например, если EntityAttribute задан с массивом [Компания, Человек], то физически в базе данных это будет одно поле, скажем `CONTACTKEY` с ограничением:
```sql
ALTER TABLE <some_table>
ADD CONSTRAINT gd_fk_some_table_contactkey
FOREIGN KEY (contactkey) REFERENCES gd_contact (id)
ON DELETE NO ACTION
ON UPDATE CASCADE
```

>В Гедымине, в такой ситуации, мы могли ограничить типы бизнес-классов, участвующих в ссылке, с помощью значения поля-селектора. Например, `CONTACTTYPE IN (2, 3, 5)`.
>При этом для отображения можно было выбрать только поле из **общей** таблицы.

Первый вопрос: как задать в запросе требуемые поля, когда EntityAttribute ссылается на массив Entity? 

Поскольку в момент формирования EntityQuery мы имеем под рукой только ER Model, которая ничего не знает о физической структуре реляционной базы данных, 

