# Отображение и фильтрация данных из EntityAttribute сущности

Разделим задачу на три части:

1. Отображение заданных атрибутов из связанной сущности EntityAttribute в выборке.  
  1a. EntityAttribute ссылается только на одну сущность.  
  1b. EntityAttribute ссылается на несколько сущностей, не имеющих общего родителя.  
  1с. EntityAttribute ссылается на базовую сущность, у которой в базе данных есть наследники.  
2. Извлечение данных Entity по заданному ИД из результирующей выборки.  
  2a. Мы работаем с результатом, полученным от EntityQuery.
  2b. Мы работаем с произвольным SQL запросом.
3. Формирование условий выборки записей Entity по атрибутам из связанной сущности EntityAttribute.  
  3a. EntityAttribute ссылается только на одну сущность.  
  3b. EntityAttribute ссылается на несколько сущностей, не имеющих общего родителя.  
  3с. EntityAttribute ссылается на базовую сущность, у которой в базе данных есть наследники.  

# Отображение заданных атрибутов из связанной сущности EntityAttribute в выборке

## 1a. EntityAttribute ссылается на одну сущность

Предположим, перед нами стоит задача реализовать следующий пользовательский интерфейс:

1. Отобразить на экране список накладных на реализацию нашей продукции. 
2. У сущности **Накладная** EntityAttribute покупателя содержит ссылку только на одну сущность **Компания**.
3. В списке документов на экране, среди прочих атрибутов документа, мы хотим видеть **Наименование покупателя** и **Телефон покупателя**.
4. Рядом со списком необходимо отобразить панель, где для покупателя из текущей позиции в списке документов, показывать историю его покупок и платежей.

Для решения данной задачи, система должна: 
1. Определить из адаптеров атрибутов сущности **Компания** в каких таблицах находятся запрашиваемые поля. 
2. При формировании SQL запроса присоединить по `JOIN` или `LEFT JOIN` (в зависимости от того, обязательным или нет является атрибут **Компания** у сущности **Накладная**) определенную в п.1. таблицу(ы).
3. В части `SELECT` запроса добавить в список указанные поля.

Для нашей структуры БД части SQL запроса будут выглядеть следующим образом:
```sql
SELECT 
  ...
  z.customerkey,
  c.name,
  c.phone
  ...
FROM
  <таблица накладной> z
  JOIN gd_contact c ON z.customerkey = c.id
  ...
```
Если же будет задано показать **Наименование** и **УНП**, которые лежат в разных таблицах сущности **Компания**, то запрос примет следующий вид:
```sql
SELECT 
  ...
  z.customerkey,
  c.name,
  t.taxid
  ...
FROM
  <таблица накладной> z
  JOIN gd_contact c ON z.customerkey = c.id
  LEFT JOIN gd_companycode t ON z.customerkey = t.contactkey
  ...
```
Обратите внимание, что таблица `GD_COMPANYCODE` подключается через `LEFT JOIN` так как в адаптере сущности **Компания** данная таблица указана как `weak relation`:
```json
"adapter": {
  "relation": [
    {
      "relationName": "GD_CONTACT",
      "pk": [
        "ID"
      ],
      "selector": {
        "field": "CONTACTTYPE",
        "value": 3
      }
    },
    {
      "relationName": "GD_COMPANY",
      "pk": [
        "CONTACTKEY"
      ]
    },
    {
      "relationName": "GD_COMPANYCODE",
      "pk": [
        "CONTACTKEY"
      ],
      "weak": true
    }
  ]
}
```
В запросе так же извлекается ИД компании. При перемещении по таблице мы будем использовать этот ИД для того, чтобы формировать запросы на определение истории покупок и платежей клиента.

## 1b. EntityAttribute ссылается на несколько сущностей, не имеющих в ER модели общего родителя

Рассмотрим пример аналогичный предыдущему, но теперь EntityAttribute сущности **Накладная** пусть ссылается на две сущности **Компания** и **Человек**.

Поставлена задача извлечь в запросе следующие данные: 
* Наименование компании, контактный телефон и УНП
* ФИО человека, контактный телефони и номер паспорта

В структуре нашей реляционной базы данных данная информация расположена в следующих таблицах:

```
               +-------------------+
               | GD_CONTACT        |
               | ...               |
         +-----| name              |-----+
         |     | phone             |     |
         |     | ...               |     |
         |     +-------------------+     |
         |                               |
+-------------------+        +-------------------+
| GD_PEOPLE         |        | GD_COMPANYCODE    |
| ...               |        | ...               |
| passport          |        | taxid             |
| ...               |        | ...               |
+-------------------+        +-------------------+
```
Следует понимать, что когда в ER Model мы указываем для EntityAttribute массив из нескольких Entity, в физической структуре БД это будет _одно поле_ с _одним внешним ключем (FOREIGN KEY)_, указывающим на _общую_ для всех указанных Entity таблицу.

Например, если EntityAttribute задан с массивом [Компания, Человек], то физически в базе данных это будет одно поле, скажем `CONTACTKEY` с ограничением:
```sql
ALTER TABLE <some_table>
ADD CONSTRAINT gd_fk_some_table_contactkey
FOREIGN KEY (contactkey) REFERENCES gd_contact (id)
ON DELETE NO ACTION
ON UPDATE CASCADE
```

>В Гедымине, в такой ситуации, мы могли ограничить типы бизнес-классов, участвующих в ссылке, с помощью значения поля-селектора. Например, `CONTACTTYPE IN (2, 3, 5)`.
>При этом для отображения можно было выбрать только поле из **общей** таблицы.

Первый вопрос: как задать в запросе требуемые поля, когда EntityAttribute ссылается на массив Entity? 

## 1с. EntityAttribute ссылается на базовую сущность, у которой в базе данных есть наследники 

Самый яркий пример, ссылка в базе данных на таблицу `GD_DOCUMENT`, которая является общей частью для всех типов документов, которых может быть на реальной базе данных несколько сотен.

# 2. Извлечение данных Entity по заданному ИД из результирующей выборки

## 2a. Работа с результатом выполнения EntityQuery

...

## 2b. Работа с результатом произвольного SQL запроса

Мы не сможем сразу реализовать все возможности SQL в EntityQuery. В системе будет возможность задавать произвольный SQL запрос, выполнять его на сервере и отображать результаты во фронте.

В этом случае возникнет задача открыть Entity зная только поле-ссылку и таблицу, и значение ИД из него.

Такая задача легко решается в Гедымине следующим образом:

1. Надо знать имя таблицы (не алиас таблицы!) и имя поля в таблице (не алиас поля!). Эту информацию Firebird передает вместе с выполненным запросом. Надо проследить, чтобы она прокидывалась вплоть до клиента. В Делфи это свойство **Origin** у объекта **TField**, которое имеет тип строка и формат: "имя_таблицы.имя_поля_в_таблице".
2. Надо знать о том на *какую таблицу* ссылается поле из выборки, из п.1.
3. По таблице, на которую ведет ссылка, Гедымин определяет бизнес-класс (в терминах gdmn -- это сущность). Если бизнес-классов несколько, то берется самый базовый из них по иерархии наследования. Например, если это ссылка на таблицу `GD_DOCUMENT`, то классов, основанных на ней, на реальной базе несколько сотен, но система возьмет их общего родителя -- `TgdcDocument`.
4. Создается экземпляр определенного в п.3. бизнес-класса, с помощью подмножества `ByID` открывается набор данных из одной записи, соответствующей заданному ИД.
5. Для этой записи вызывается метод `GetCurrRecordClass`, который вернет класс и подтип именно для этой записи. Как он работает -- зависит от конкретного класса. Например, для контактов этот метод будет ориентироваться на значение поля-селектора `CONTACTTYPE`, для документов -- определять информацию о типе и наследовании документов из таблицы `GD_DOCUMENTTYPE`. Ссылка на тип документа хранится в поле `DOCUMENTTYPEKEY` таблицы `GD_DOCUMENT`.
6. Если в п.5. мы получили класс отличный, от класса текущего объекта, то создаем новый экземпляр и повторяем с п.4. Если класс совпадает, то начинаем выполнять запрашиваемые действия. Например, открываем диалоговое окно на редактирование записи.

# 3. Формирование условий выборки записей Entity по атрибутам из связанной сущности EntityAttribute

## 3a. EntityAttribute ссылается только на одну сущность

## 3b. EntityAttribute ссылается на несколько сущностей, не имеющих общего родителя

## 3с. EntityAttribute ссылается на базовую сущность, у которой в базе данных есть наследники
