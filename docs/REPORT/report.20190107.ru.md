Целью версии 0.1 была загрузка **ER Model** на клиента, отображение её на экране в виде мастер-дитэйл списка сущностей и атрибутов, выбор любой сущности пользователем, формирование **IQuery** и отсылка на сервер для выполнения, ожидание и чтение результата, с последующим размещением в **RecordSet** и отображение на экране в гриде.

Трехнедельное опоздание с завершением версии 0.1 в основном связано с тем, что мы всё еще находимся в стадии изучения, оценки и выбора технологий для реализации нашего проекта. В частности, было потрачено время на изучение библиотеки **MobX** и оценки возможности перехода с **Redux** на эту библиотеку. Пока у меня нет однозначного мнения. Каждая библиотека имеет свои сильные и слабые стороны, а также вызывает ряд вопросов в контексте применения в рамках нашего проекта.

## Redux

"+" -- данные проекта находятся в одном месте. Поток данных строго направлен:
```
событие -> экшен -> диспетчер -> middleware -> редусер -> connect -> презентационный компонент
```

"-" -- разделение на пять частей (презентационный компонент-контейнер-редусер-экшен криэйторы-мидлвэр) каждого модуля программы выглядит сложным и запутанным.

"-" -- чтобы использовать **RecordSet** внутри редусера, он сделан в _immutable_ стиле. Т.е. каждый метод, который приводит к изменению хотя бы одного внутреннего свойства возвращает копию объекта, которую мы располагаем в новой версии стэйта. Это хорошо для редусера, но совершенно неудобно для любого другого кода, который попытается использовать **RecordSet**. А такой код у нас будет и внутри самой платформы, и внутри прикладных решений. Мы также не можем назначать обработчики событий (OnBeforeScroll, OnAfterScroll и т.п.) так как они будут срабатывать внутри редусера, где запрещены любые side effects. Фактически, если мы хотим использовать события объекта, то надо отказаться от [полного набора экшенов](../../packages/gdmn-recordset/src/recordSetActions.ts), оставив только три из них: создать новый RecordSet, записать в стэйт измененный RecordSet, удалить RecordSet. Что нивелирует часть преимуществ от использования **Redux**.

"-" -- при использовании наследования классов презентационных компонентов мы вынуждены вручную составлять функцию _connect_ из кусочков от всех родительских классов. Возможно, здесь можно применить _compose_ нескольких функций, но у меня не получилось с первой попытки -- переставали работать типы.


## MobX

Мы не использовали **MobX**, поэтому предположения ниже сделаны на основе чтения документации и нуждаются в проверке на практике:

"+" -- можно работать с любыми объектами. Не требуется _immutability_.

"+" -- асинхронный код можно свободно использовать внутри action без всяких дополнительных ухищрений вроде middleware библиотек в **Redux**. 

"+/-" -- данные могут группироваться по смысловым доменам и располагаться там, где удобно разработчику. 

"-" -- свобода по размещению кода и данных где угодно может привести к тому, что бизнес-логика начнет залазить внуть интерфейса пользователя и мы получим повторение проблем Гедымина, когда код изменения данных в базе может распологаться внутри диалогового окна и вызываться по событию _OnChange_ компонента выпадающий список.

"-" -- непонятно, как заставить систему реагировать на конкретное изменение экземпляра сложного класса **RecordSet**, например только на перемещение курсора, а не на любое изменение объекта вообще.

"-" -- неизвестно как поведет себя система, когда количество наблюдаемых данных перевалит за несколько сотен и на экране будут находиться десятки компонентов, наблюдающих за изменениями.

## Вывод

В течение цикла версии 0.2 мы остаёмся на **Redux**, к которому попробуем применить оптимизирующие и упрощающие практики: 

1. Посмотреть библиотеки **immer** и **lodash/fp** и оценить целесообразность их использования.
2. Подключить **redux-freeze** в режиме разработчика.
3. Оценить возможность переноса всей сложной/асинхронной логики из контейнера на уровень _middleware_. Есть опасение, что такой подход может замедлить выполнение программы, так как цепочка _middleware_ вызывается при каждом dispatch action, в то время, как прикладной код, расположенный в обработчике события для конкретного компонента, вызывается только если компонент на экране и происходит именно это событие.
4. Посмотреть и применить всё здравое и полезное из проекта **redux-starter-kit**.

Мы продолжим изучение документации по **MobX** и по мере возможности переведем на эту библиотеку один из наших проектов **gdmn-nlp-demo** или **gdmn-grid-demo** для того, чтобы на практике получить ответы на указанные выше вопросы.

## node-firebird-driver

Следующая проблема с которой мы столкнулись, на которую потратили много времени и которая до конца еще так и не решена -- это ошибка в драйвере _node-firebird_ (или ошибка в нашем коде, приводящая к ошибке в драйвере). Без её устранения не имеет смысла двигаться дальше версии 0.2. Если мы не сможем найти и устранить ошибку в нашем коде (или ее там просто нет), то следует сосредоточиться на получении небольшого автономного примера, который позволит разработчику воспроизвести и устранить проблему на стороне драйвера.

## скорость! скорость! скорость!

Мало чтобы проект работал правильно, он должен работать еще и быстро. 

Мы потратили часть времени для поиска (пока теоретического) решения с долговыполняющимися блоками кода на стороне nodejs. Решили остановиться на пуле _child_process_, каждый из которых будет подключаться к базе данных, формировать свой экземпляр ERModel и прочие объекты и ждать запроса от основного потока. Основной поток будет дифференцировать клиентские запросы и те из них, которые потенциально могут потребовать значительных вычислительных мощностей, переадресовывать стороннему процессу. По завершении выполнения результат передается основному процессу, который отсылает его клиенту. 

Данная схема нуждается в практической проверке. Сразу виден её недостаток в том, что мы не сможем передавать открытые транзакции между разными процессами. Т.е. алгоритм, выполняющийся в выделенном стороннем процессе, должен быть атомарным с точки зрения доступа к базе данных -- открыли транзакцию, провели ряд операций по чтению либо изменению данных, закрыли транзакцию. 

Любой сложный процесс, который потребует долговременно открытой транзакции и интеракции клиент-сервер в рамках _этой_ открытой транзакции, может быть выполнен только внутри основного процесса со всеми прелестями ввиде блокировки основной петли сообщений.

Альтернативные решения:

* обращение к серверу базы данных только из основной петли событий и реализация протокола взаимодействия _child_process_ или _worker_thread_ с основной петлей для старта/комита транзакции, выполнения запроса, получения и передачи результата.
* кластер, когда каждый экземпляр это обособленный полноценный тяжеловесный сервер, обслуживающий только своего клиента или небольшую группу клиентов.

Остаются малые запросы и небольшие блоки кода, которые нецелесообразно выделять в отдельные процессы/нити. Например, визуальный компонент _выпадающий список_ для выбора сущности на форме, который работает следующим образом: 

1. пользователь вводит часть наименования
2. по нажатию специальной клавиши или через установленную паузу на сервер формируется запрос (IQuery)
3. сервер выполняет запрос на базе данных и получает список объектов, удовлетворяющих указанному условию
4. список объектов пересылается на клиента, где отображается в выпадающем окошке для выбора пользователем

Мы должны создать тест (его можно просто захардкодить прямо в gdmn-front), который будет непрерывно формировать простые запросы указанного выше вида по разным сущностям и выполнять их на сервере с подсчетом среднего количества выполненных запросов в единицу времени.

В качестве граничного случая можно рассмотреть скорость выполнения одного и того же запроса к серверу.

И в качестве еще более граничного случая можно рассмотреть скорость выполнения обращения к серверу без запросов к базе данных.

По итогам теста следует принять решение о целесообразности дальнейшего использования платформы **nodejs**, либо о необходимости глубокой оптимизации внутренних механизмов **gdmn-back** и **gdmn-db**.

## дальнейшее развитие проекта, версия 0.2

Кроме ответов на вышепоставленные вопросы основные цели версии 0.2:

1. инкрементная подгрузка больших объемов данных, скролинг их на клиенте.
2. получение из базы на сервере, загрузка на клиента и отображение данных всех возможных типов, включая: EntityAttribute, SetAttribute, DetailAttribute. Отображение простых и древовидных списков.
3. редактирование данных в отдельной экранной форме (аналог диалогового окна в Гедымине).
4. настройка пользователем внешнего вида таблиц на свой вкус и сохранение этих настроек между запусками программы (реализация аналога _хранилища_ в Гедымине).

Мы стараемся выйти на короткие 5-ти недельные итерации, но пока не будут решены вопросы, требующие проведения исследовательских работ, указать точную дату выполнения не представляется возможным.

